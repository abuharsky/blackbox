# FAQ (RU)

## Почему `initial` в Flow не эмитится первым?
Потому что initial — fallback. Sync источники с готовыми значениями перебивают initial немедленно, чтобы не было «мигания».

## Почему `compute()` может вызываться несколько раз?
Потому что планировщик и подписки могут инициировать дополнительные попытки вычисления. Контракт обычно фиксирует результат и инварианты, а не counts.

## Почему `DependencyResolver.of` бросает `StateError`?
Это fail-fast инвариант: dependency либо зарегистрирована и готова, либо это ошибка. Для transient состояния используйте `onError`.

## Можно ли тестировать приватные методы?
В Dart приватные символы видны только внутри library. Для coverage-friendly тестов используйте `@visibleForTesting` bridge-функции.
